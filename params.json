{"name":"Hexagonal TDD in Ruby - Screencast Series","tagline":"How to TDD a hexagonal application","body":"In this screencast series, we will demystify hexagonal architectures, showing a simple way to TDD a hexagonal application into existence. We will build pieces of Pivotal's \"Whiteboard\" Application (a web application that facilitates both the presentation and the sharing out of office-wide standup items). \r\n\r\nAll feedback greatly appreciated. Feel free to: \r\n* open an issue on this project's [github page](https://github.com/moonmaster9000/hexagonal_tdd_in_ruby/issues)\r\n* [tweet](https://twitter.com/moonmaster9000) at `@moonmaster9000` \r\n* email `hexagonal.tdd.in.ruby@gmail.com`\r\n\r\n### Episode 1\r\n\r\n<https://youtu.be/XEkR3hQvcIc>\r\n\r\nIn this episode, we TDD our first use case for the whiteboard application into existence. We discuss the difference between high level policy and low level detail, and we tease out those boundaries.\r\n\r\nWe hand roll a spy and a fake across two significant (and common) architectural boundaries – and we discuss when we use test doubles, and why. \r\n\r\nWe also create a contract for our fake repository, and tease out a message passing protocol between the use case and GUI. \r\n\r\n\r\n### Episode 2\r\n\r\n_Coming Soon_\r\n\r\nIn this episode, we create a Rails application and plug it into our high level policy. We show how to use our fake in memory repository for now, deferring the decision for how to concretely persist entities a bit longer.\r\n\r\n\r\n### Episode 3\r\n\r\n_Coming Soon_\r\n\r\nIn this episode, we create a concrete persistence plugin for our high level policy; we turn it into a Rails engine, and show how we use ActiveRecord under the hood. We discuss the common pitfalls developers face with Rails and ActiveRecord, and how we avoid them.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}